## 코딩 테스트 정복을 위한 파이썬 핵심 자료구조 가이드

코딩 테스트에서 문제 해결의 열쇠는 종종 적절한 자료구조의 선택에 있습니다. 파이썬은 간결한 문법과 함께 강력하고 다양한 내장 자료구조를 제공하여 코딩 테스트에 매우 유리한 언어입니다. 이 가이드는 코딩 테스트에서 빈번하게 활용되는 파이썬의 핵심 자료구조들을 소개하고, 각 자료구조의 특징과 사용법을 예제 코드와 함께 설명합니다.

### 1. 리스트 (List)

리스트는 파이썬에서 가장 기본적이고 널리 사용되는 자료구조입니다. 여러 데이터를 순서대로 저장하며, 저장된 데이터는 변경 가능합니다.

*   **주요 특징:**
    *   **순서가 있는 데이터:** 인덱스를 통해 각 요소에 접근할 수 있습니다.
    *   **변경 가능 (Mutable):** 요소의 추가, 삭제, 수정이 자유롭습니다.
    *   **다양한 데이터 타입 저장:** 숫자, 문자열, 심지어 다른 리스트까지 함께 저장할 수 있습니다.

*   **시간 복잡도:**
    *   요소 접근: O(1)
    *   끝에서 추가/삭제 (append, pop): O(1)
    *   중간에 추가/삭제: O(n)

*   **활용 예시:**
    *   데이터를 순서대로 저장하고 관리해야 할 때
    *   스택(Stack) 구현: `append()`와 `pop()` 메서드를 사용하여 LIFO(Last-In, First-Out) 구조를 쉽게 구현할 수 있습니다.
    *   큐(Queue) 구현: `append()`와 `pop(0)`를 사용할 수 있지만, 시간 효율성을 위해 `deque` 사용을 권장합니다.

```python
# 리스트 생성
a = [1, 2, 3, 4, 5]

# 요소 접근
print(a[0]) # 1

# 요소 추가
a.append(6) # [1, 2, 3, 4, 5, 6]

# 요소 삭제
a.pop() # [1, 2, 3, 4, 5]

# 슬라이싱
print(a[1:3]) # [2, 3]
```

### 2. 딕셔너리 (Dictionary)

딕셔너리는 '키(Key)'와 '값(Value)'을 한 쌍으로 묶어 저장하는 자료구조입니다. 순서가 보장되지 않으며, 키를 통해 값을 빠르게 찾아야 할 때 유용합니다.

*   **주요 특징:**
    *   **키-값 쌍:** 모든 값은 고유한 키를 가집니다.
    *   **순서 없음 (Unordered):** (파이썬 3.7+ 부터는 입력 순서가 유지되지만, 이전 버전에서는 보장되지 않습니다.)
    *   **빠른 탐색 속도:** 해시 테이블을 기반으로 구현되어 있어, 키를 통한 값의 검색, 추가, 삭제가 매우 빠릅니다.
    *   **변경 가능 (Mutable):** 새로운 키-값 쌍을 추가하거나 기존 쌍을 삭제할 수 있습니다.

*   **시간 복잡도:**
    *   검색, 추가, 삭제: 평균 O(1)

*   **활용 예시:**
    *   데이터에 이름표를 붙여 관리하고 싶을 때 (예: JSON 데이터 처리)
    *   해시 테이블을 이용한 문제 해결
    *   데이터의 등장 횟수를 셀 때 (Counter 클래스도 유용합니다.)

```python
# 딕셔너리 생성
person = {'name': 'Alice', 'age': 25}

# 값 접근
print(person['name']) # 'Alice'

# 값 추가/수정
person['city'] = 'New York'
person['age'] = 26

# 값 삭제
del person['age']

# 키 존재 여부 확인
print('name' in person) # True
```

### 3. 세트 (Set)

세트는 중복을 허용하지 않는 순서 없는 데이터의 모음입니다. 주로 데이터의 중복을 제거하거나 멤버십 테스트(특정 요소의 포함 여부 확인)에 사용됩니다.

*   **주요 특징:**
    *   **중복 불가:** 동일한 요소는 하나만 저장됩니다.
    *   **순서 없음 (Unordered):** 인덱스로 요소에 접근할 수 없습니다.
    *   **빠른 멤버십 테스트:** 특정 요소가 세트에 포함되어 있는지 매우 빠르게 확인할 수 있습니다.

*   **시간 복잡도:**
    *   추가, 삭제, 멤버십 테스트: 평균 O(1)

*   **활용 예시:**
    *   리스트에서 중복된 요소를 제거할 때
    *   두 데이터 집합의 교집합, 합집합, 차집합 등 집합 연산이 필요할 때

```python
# 세트 생성
my_set = {1, 2, 3, 3, 4}
print(my_set) # {1, 2, 3, 4}

# 요소 추가
my_set.add(5)

# 요소 삭제
my_set.remove(3)

# 멤버십 테스트
print(2 in my_set) # True

# 집합 연산
set1 = {1, 2, 3}
set2 = {3, 4, 5}
print(set1 & set2) # 교집합: {3}
print(set1 | set2) # 합집합: {1, 2, 3, 4, 5}
```

### 4. 데크 (deque)

`collections` 모듈의 `deque`는 양방향 큐(Double-Ended Queue)를 지원하는 자료구조입니다. 리스트와 달리 양쪽 끝에서의 데이터 추가 및 삭제가 O(1) 시간 복잡도를 가져, 큐(Queue)와 스택(Stack)을 모두 효율적으로 구현하는 데 사용됩니다.

*   **주요 특징:**
    *   **양방향 입출력:** 앞과 뒤에서 데이터를 추가하거나 제거하는 연산이 매우 빠릅니다.
    *   **리스트보다 빠른 큐 연산:** 리스트의 `pop(0)`는 O(n)인 반면, `deque`의 `popleft()`는 O(1)입니다.

*   **시간 복잡도:**
    *   양쪽 끝에서 추가/삭제 (append, appendleft, pop, popleft): O(1)

*   **활용 예시:**
    *   너비 우선 탐색 (BFS) 알고리즘에서 큐 구현
    *   스택 구현
    *   슬라이딩 윈도우 문제

```python
from collections import deque

# 데크 생성
dq = deque([1, 2, 3])

# 앞쪽에 요소 추가
dq.appendleft(0) # deque([0, 1, 2, 3])

# 뒤쪽에 요소 추가
dq.append(4) # deque([0, 1, 2, 3, 4])

# 앞쪽 요소 제거
dq.popleft() # 0, dq는 deque([1, 2, 3, 4])

# 뒤쪽 요소 제거
dq.pop() # 4, dq는 deque([1, 2, 3])
```

### 5. 힙 (heapq)

파이썬의 `heapq` 모듈은 최소 힙(Min Heap) 자료구조를 제공합니다. 힙은 완전 이진 트리를 기반으로 하며, 부모 노드의 값이 항상 자식 노드의 값보다 작거나 같은 특징을 가집니다. 이를 통해 가장 작은 값을 O(1) 시간 복잡도로 조회할 수 있습니다.

*   **주요 특징:**
    *   **최소 힙:** 항상 가장 작은 요소가 루트에 위치합니다.
    *   **효율적인 우선순위 큐:** 우선순위가 가장 높은(가장 작은 값) 요소를 빠르게 추출해야 할 때 유용합니다.

*   **시간 복잡도:**
    *   요소 추가 (heappush): O(log n)
    *   가장 작은 요소 삭제 (heappop): O(log n)

*   **활용 예시:**
    *   우선순위 큐 구현
    *   다익스트라(Dijkstra) 알고리즘과 같은 최단 경로 탐색 문제
    *   여러 데이터 중 가장 작거나 큰 K개의 요소를 찾을 때

```python
import heapq

# 리스트를 힙으로 변환
heap = [4, 1, 7, 3, 8, 5]
heapq.heapify(heap)
print(heap) # [1, 3, 5, 4, 8, 7] (힙 속성을 만족하는 리스트)

# 요소 추가
heapq.heappush(heap, 2)

# 가장 작은 요소 제거
smallest = heapq.heappop(heap)
print(smallest) # 1
```