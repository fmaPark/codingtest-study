네, 코딩 테스트의 기본이자 가장 중요한 알고리즘 중 하나인 **정렬(Sorting)**에 대해 설명해 드릴게요.

# 정렬 (Sorting)

## 1. 개념 요약 (What is it?)

정렬이란, 여러 개의 데이터(숫자, 문자열 등)를 주어진 기준에 따라 오름차순(ascending)이나 내림차순(descending)으로 순서대로 나열하는 것을 말합니다.

## 2. 핵심 아이디어 (Core Idea)

핵심 아이디어는 **'비교'와 '교환'**입니다. 두 데이터의 크기를 비교하고, 정해진 기준(오름차순/내림차순)에 맞지 않으면 위치를 바꿉니다. 이 과정을 모든 데이터에 대해 반복하여 전체를 순서대로 만드는 것이죠.

어떤 방식으로 비교하고 교환할지에 따라 다양한 정렬 알고리즘(버블 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬 등)이 존재합니다. 하지만 코딩 테스트에서는 대부분 내장 정렬 함수를 사용하므로, 모든 정렬 알고리즘을 직접 구현하기보다 **'언제 정렬을 사용해야 하는지'**를 아는 것이 훨씬 중요합니다.

*   **비유**: 책꽂이에 책을 저자 이름순이나 제목순으로 정리하는 것과 같습니다. 기준을 정하고, 책들을 비교하며 순서에 맞게 제자리를 찾아주는 과정이죠.

## 3. 코딩 테스트 활용 전략 (When to Use)

정렬은 문제 해결을 위한 '준비 단계' 또는 '핵심 도구'로 매우 빈번하게 사용됩니다.

*   **문제에서 직접 요구할 때**: "숫자들을 오름차순으로 정렬하여 출력하시오." 와 같이 명시적으로 요구하는 경우.
*   **탐색 알고리즘의 전처리**:
    *   **이진 탐색(Binary Search)**을 사용하려면 데이터가 반드시 정렬되어 있어야 합니다. "정렬된 배열에서 특정 값을 찾아라"라는 문제의 핵심 전제 조건입니다.
*   **그리디 알고리즘(Greedy Algorithm)**:
    *   전체적인 최적해를 구하기 위해 '매 순간 최선의 선택'을 해야 할 때, 그 기준을 만들기 위해 정렬을 사용합니다. (예: "회의 시간이 겹치지 않게 가장 많은 회의를 배정하기" -> 회의 종료 시간을 기준으로 정렬)
*   **값들의 비교를 용이하게 만들 때**:
    *   가장 큰 값과 가장 작은 값의 차이를 구하거나, 인접한 값들을 비교해야 할 때 정렬하면 문제가 매우 간단해집니다. (예: "배열에서 인접한 두 수의 차이가 가장 큰 경우는?")
*   **중복 제거 또는 개수 세기**: 정렬하면 동일한 값들이 연달아 나타나므로 중복을 찾거나 개수를 세기 쉬워집니다.

**키워드**: "오름차순", "내림차순", "순서대로", "가장 큰/작은 N개", "정렬하여" 등의 단어가 나오면 일단 정렬을 떠올려야 합니다.

## 4. 시간 복잡도 및 장단점 (Complexity & Trade-offs)

어떤 정렬 알고리즘을 사용하느냐에 따라 시간 복잡도가 달라집니다.

*   **O(N²)**: 선택 정렬, 버블 정렬, 삽입 정렬
    *   **장점**: 구현이 매우 간단하고 직관적입니다.
    *   **단점**: 데이터 개수(N)가 커지면 (예: 100,000개) 속도가 기하급수적으로 느려져 시간 초과가 발생합니다. 코딩 테스트에서는 거의 사용하지 않습니다.
*   **O(N log N)**: **퀵 정렬, 병합 정렬, 힙 정렬**
    *   **장점**: 데이터 개수가 많아도 매우 빠른 성능을 보장합니다. **코딩 테스트에서 사용하는 정렬은 대부분 이 시간 복잡도를 가집니다.**
    *   **단점**: O(N²) 알고리즘에 비해 구현이 상대적으로 복잡합니다.
    *   **핵심**: **Python의 내장 정렬 함수 `sort()`, `sorted()`는 평균적으로 O(N log N)의 시간 복잡도를 보장**하므로, 안심하고 사용하면 됩니다.

## 5. Python 구현 템플릿 (Python Template)

코딩 테스트에서는 복잡한 정렬 알고리즘을 직접 구현하기보다, 파이썬이 제공하는 강력한 내장 함수를 잘 활용하는 것이 핵심입니다.

### 1. 기본 정렬

```python
# 숫자 리스트 정렬
numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# 1. sorted() 함수: 원본 리스트는 유지하고, 정렬된 새 리스트를 반환
sorted_numbers = sorted(numbers)
print(f"sorted() 결과 (새 리스트): {sorted_numbers}")
print(f"원본 리스트: {numbers}")

# 2. .sort() 메소드: 원본 리스트 자체를 정렬 (in-place sort)
numbers.sort()
print(f".sort() 적용 후 원본 리스트: {numbers}")

# 내림차순 정렬
numbers.sort(reverse=True)
print(f"내림차순 정렬: {numbers}")
```

### 2. 복잡한 데이터 정렬 (key 활용) - **매우 중요!**

리스트 안에 리스트, 튜플, 딕셔너리가 있을 때, 특정 기준(key)으로 정렬할 수 있습니다. `lambda` 함수와 함께 사용하는 경우가 많습니다.

```python
# 2차원 배열 (좌표) 정렬
points = [[3, 4], [1, 2], [3, 1], [5, 0]]

# 기준 1: x좌표(index 0) 기준으로 오름차순 정렬
points.sort(key=lambda p: p[0])
print(f"x좌표 기준 정렬: {points}") # [[1, 2], [3, 4], [3, 1], [5, 0]]

# 기준 2: y좌표(index 1) 기준으로 오름차순 정렬
points.sort(key=lambda p: p[1])
print(f"y좌표 기준 정렬: {points}") # [[5, 0], [3, 1], [1, 2], [3, 4]]

# 기준 3: 다중 조건 정렬 (x좌표 오름차순, x가 같으면 y좌표 오름차순)
# key에 튜플을 반환하도록 하면, 튜플의 앞 요소부터 순서대로 비교하여 정렬
points.sort(key=lambda p: (p[0], p[1]))
print(f"x 오름차순, y 오름차순 정렬: {points}") # [[1, 2], [3, 1], [3, 4], [5, 0]]
```