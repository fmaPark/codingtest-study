# 깊이 우선 탐색 (DFS, Depth-First Search)

## 1. 개념 요약 (What is it?)

DFS는 그래프나 트리 구조에서, 한 경로를 따라 **최대한 깊이 들어간 후**, 더 이상 갈 곳이 없으면 되돌아와 다른 경로를 탐색하는 알고리즘입니다.

## 2. 핵심 아이디어 (Core Idea)

핵심 아이디어는 **"일단 갈 수 있는 데까지 끝까지 가보자"** 입니다. 미로를 탐험할 때 한쪽 벽을 따라 계속 가다가 막다른 길을 만나면, 바로 이전 갈림길로 돌아와 다른 길로 다시 가는 방식과 같습니다.

이 '되돌아오는' 과정을 구현하기 위해 **스택(Stack)** 자료구조를 사용합니다.
*   **재귀 함수**: 함수 호출 스택이 스택 역할을 자연스럽게 수행합니다. (구현이 간편해 가장 많이 사용)
*   **명시적 스택**: 직접 스택 자료구조를 만들어 사용합니다.

## 3. 코딩 테스트 활용 전략 (When to Use)

*   **모든 경로 탐색**: 특정 지점에서 시작하여 도달 가능한 모든 경로를 찾아야 할 때 사용합니다.
*   **연결 요소 찾기**: 그래프가 몇 개의 독립적인 덩어리(Connected Component)로 이루어져 있는지 확인할 때 유용합니다.
*   **경로의 존재 여부 확인**: 특정 노드에서 다른 노드로 가는 경로가 존재하는지만 확인하고 싶을 때 사용합니다. (경로가 여러 개여도 상관없음)
*   **백트래킹(Backtracking)** 알고리즘의 기반이 됩니다.

**키워드**: "모든 경우의 수", "모든 정점 방문", "연결된 모든 것" 등의 표현이 나오면 DFS를 우선적으로 고려할 수 있습니다.

## 4. 시간 복잡도 및 장단점 (Complexity & Trade-offs)

*   **시간 복잡도**: **O(V + E)**
    *   V: 정점(Vertex)의 수, E: 간선(Edge)의 수
    *   모든 정점과 간선을 한 번씩 방문하기 때문입니다.
*   **장점**:
    *   구현이 상대적으로 간단합니다 (특히 재귀 함수 사용 시).
    *   현재 경로상의 노드들만 기억하면 되므로, BFS에 비해 공간 복잡도가 낮은 경우가 많습니다.
*   **단점**:
    *   찾은 해가 최단 경로가 아닐 수 있습니다.
    *   경로가 매우 긴 경우, 스택 오버플로우가 발생할 수 있습니다. (재귀 깊이 제한)

## 5. Python 구현 템플릿 (Python Template)

```python
# DFS 구현 템플릿 (재귀 방식)

def dfs_recursive(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs_recursive(graph, i, visited)

# 예시 그래프 (인접 리스트 방식)
# 각 노드 번호는 1부터 시작한다고 가정
graph = [
    [],       # 0번 노드는 사용 안 함
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 방문 여부를 기록할 리스트
visited = [False] * 9 # 노드가 8개이므로 9개짜리 리스트 생성

print("DFS 탐색 순서 (재귀):")
dfs_recursive(graph, 1, visited) # 1번 노드에서 시작
# 출력: DFS 탐색 순서 (재귀): 1 2 7 6 8 3 4 5
```

---

# 너비 우선 탐색 (BFS, Breadth-First Search)

## 1. 개념 요약 (What is it?)

BFS는 그래프나 트리 구조에서, 시작점을 기준으로 **가까운 노드부터 순서대로** 탐색하는 알고리즘입니다.

## 2. 핵심 아이디어 (Core Idea)

핵심 아이디어는 **"가까운 것부터 차례차례 정복하자"** 입니다. 호수에 돌을 던졌을 때 물결이 동심원을 그리며 퍼져나가는 모습과 같습니다. 시작점에서 가장 가까운 1촌 노드들을 모두 방문하고, 그다음 2촌 노드들을 모두 방문하는 식으로 탐색을 진행합니다.

이 '가까운 순서'를 지키기 위해 **큐(Queue)** 자료구조를 사용합니다.

## 3. 코딩 테스트 활용 전략 (When to Use)

*   **최단 경로/거리 찾기 (가중치가 없는 그래프에서)**: BFS의 가장 대표적인 활용 사례입니다. 시작점에서부터 레벨(거리) 순으로 탐색하기 때문에, 특정 목적지를 발견하는 순간 그 경로가 최단 경로임이 보장됩니다.
*   **네트워크나 관계에서 특정 단계 내에 있는 모든 요소를 찾을 때**: "내 친구의 친구까지 모두 찾기"와 같은 문제에 적합합니다.

**키워드**: **"최단 거리", "최소 비용/시간", "가장 빠른 길"** 이라는 단어가 문제에 나오면, 99% BFS 문제입니다.

## 4. 시간 복잡도 및 장단점 (Complexity & Trade-offs)

*   **시간 복잡도**: **O(V + E)**
    *   DFS와 마찬가지로 모든 정점과 간선을 한 번씩 방문합니다.
*   **장점**:
    *   시작점에서 다른 모든 노드까지의 최단 경로를 찾을 수 있습니다.
*   **단점**:
    *   경로가 길어질수록 탐색해야 할 노드가 많아져 DFS보다 더 많은 메모리가 필요할 수 있습니다.
    *   재귀로 구현하기 어렵습니다.

## 5. Python 구현 템플릿 (Python Template)

```python
from collections import deque

# BFS 구현 템플릿

def bfs(graph, start, visited):
    # 탐색을 위한 큐 생성, 시작 노드를 큐에 넣음
    queue = deque([start])
    # 시작 노드 방문 처리
    visited[start] = True

    while queue: # 큐가 빌 때까지 반복
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        print(v, end=' ')

        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


# 예시 그래프 (DFS와 동일)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9

print("\nBFS 탐색 순서:")
bfs(graph, 1, visited) # 1번 노드에서 시작
# 출력: BFS 탐색 순서: 1 2 3 8 7 4 5 6```

### DFS vs BFS 핵심 비교

| 구분 | **DFS (깊이 우선 탐색)** | **BFS (너비 우선 탐색)** |
| :--- | :--- | :--- |
| **탐색 방식** | 한 놈만 팬다! (깊게) | 주변부터 챙긴다! (넓게) |
| **자료구조** | 스택(Stack), 재귀 함수 | 큐(Queue) |
| **핵심 활용** | 모든 경로 탐색, 경로 존재 여부 | **최단 거리 탐색** |
| **속도** | 경우에 따라 다름 | 경우에 따라 다름 (복잡도는 동일) |
| **메모리** | 상대적으로 적게 사용 | 상대적으로 많이 사용 |