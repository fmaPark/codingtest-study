
# 해시 (Hash)

## 1. 개념 요약 (What is it?)

해시는 키(Key)와 값(Value)을 하나의 쌍으로 저장하여, 키를 통해 값을 매우 빠르게 찾아낼 수 있는 자료구조입니다. 파이썬에서는 딕셔너리(`dict`)가 해시 테이블로 구현되어 있습니다.

## 2. 핵심 아이디어 (Core Idea)

핵심 아이디어는 **"해시 함수(Hash Function)"** 입니다. 해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터(해시 값)로 매핑하는 함수입니다.

1.  **저장**: 키를 해시 함수에 넣어 해시 값(메모리 주소)을 얻고, 해당 주소에 값을 저장합니다.
2.  **탐색**: 찾고 싶은 키를 해시 함수에 넣어 동일한 해시 값을 얻고, 해당 주소에 저장된 값을 즉시 가져옵니다.

*   **비유**: 학생들의 번호(Key)를 이용해 사물함(Hash Table) 위치를 바로 찾아 물건(Value)을 꺼내는 것과 같습니다. '37번 학생'의 사물함은 항상 정해진 '37번 위치'에 있어 바로 찾을 수 있죠.

## 3. 코딩 테스트 활용 전략 (When to Use)

*   **빠른 탐색이 필요할 때**: 특정 데이터가 존재하는지, 혹은 몇 개나 있는지 빠르게 확인해야 할 때 사용합니다. (예: "참가자 명단에 '홍길동'이 있는가?")
*   **데이터 개수 세기**: 각 데이터가 몇 번 등장했는지 쉽게 계산할 수 있습니다. (예: "가장 많이 팔린 과일은 무엇인가?")
*   **중복 제거**: 데이터를 키로 저장하면 자연스럽게 중복된 데이터를 제거할 수 있습니다.

**키워드**: "찾기", "개수 세기", "중복 확인", "매핑" 등의 단어가 문제에 등장하면 해시 사용을 고려해볼 수 있습니다.

## 4. 시간 복잡도 및 장단점 (Complexity & Trade-offs)

*   **시간 복잡도**:
    *   데이터 추가, 삭제, 조회(탐색): **평균 O(1)**
    *   최악의 경우(해시 충돌이 심할 때): O(N)
    *   *코딩 테스트에서는 평균적인 경우인 O(1)로 간주하고 풀이하는 경우가 대부분입니다.*
*   **장점**:
    *   데이터의 양에 상관없이 추가, 삭제, 조회가 매우 빠릅니다.
    *   구현이 직관적이고 파이썬의 `dict`를 사용하면 매우 편리합니다.
*   **단점**:
    *   데이터가 순서대로 저장되지 않습니다.
    *   해시 충돌(서로 다른 키가 같은 주소에 할당되는 경우)이 발생하면 성능이 저하될 수 있습니다.

## 5. Python 구현 템플릿 (Python Template)

```python
# 해시(딕셔너리)를 활용한 참가자 완주 여부 확인 예제

def solution(participant, completion):
    # 1. 해시 생성 (참가자 이름: 인원수)
    participant_dict = {}
    for p in participant:
        if p in participant_dict:
            participant_dict[p] += 1
        else:
            participant_dict[p] = 1

    # 2. 완주한 선수 제거
    for c in completion:
        participant_dict[c] -= 1

    # 3. 완주하지 못한 선수 찾기
    # 값이 0이 아닌 (즉, 1인) 선수가 완주하지 못한 선수
    for key, value in participant_dict.items():
        if value > 0:
            return key

# collections.Counter를 사용하면 더 간단하게 구현 가능
import collections

def solution_advanced(participant, completion):
    # participant의 카운터에서 completion의 카운터를 뺌
    answer = collections.Counter(participant) - collections.Counter(completion)
    # 남은 키(선수 이름)의 리스트에서 첫 번째 요소를 반환
    return list(answer.keys())[0]

# 예시
participant = ["leo", "kiki", "eden"]
completion = ["eden", "kiki"]
print(f"완주하지 못한 선수: {solution(participant, completion)}") # 출력: 완주하지 못한 선수: leo
```

---

# 스택 (Stack)

## 1. 개념 요약 (What is it?)

스택은 데이터가 순서대로 쌓이는 자료구조로, 가장 마지막에 들어온 데이터가 가장 먼저 나가는 **후입선출(LIFO, Last-In, First-Out)** 특징을 가집니다.

## 2. 핵심 아이디어 (Core Idea)

스택은 한쪽 끝이 막힌 통과 같습니다. 데이터를 넣는 작업(`push`)과 빼는 작업(`pop`)이 모두 열린 쪽(top)에서만 일어납니다.

*   **비유**: 접시를 쌓아놓는 것을 생각하면 쉽습니다. 가장 위에 쌓은 접시(마지막에 들어온 데이터)를 가장 먼저 꺼내서 사용하게 됩니다.

## 3. 코딩 테스트 활용 전략 (When to Use)

*   **역순 처리**: 입력된 데이터의 순서를 뒤집어서 처리해야 할 때 유용합니다.
*   **괄호 짝 맞추기**: 여는 괄호를 만나면 스택에 넣고(`push`), 닫는 괄호를 만나면 스택에서 꺼내(`pop`) 짝이 맞는지 검사하는 문제에 사용됩니다.
*   **깊이 우선 탐색(DFS)**: 재귀 함수 대신 스택을 이용하여 DFS를 구현할 수 있습니다.
*   **백트래킹**: 탐색 과정에서 특정 지점으로 되돌아와야 할 때 사용됩니다.

## 4. 시간 복잡도 및 장단점 (Complexity & Trade-offs)

*   **시간 복잡도**:
    *   데이터 추가(`push`), 삭제(`pop`): **O(1)**
*   **장점**:
    *   구조가 단순하고 구현이 쉽습니다.
    *   데이터를 저장하고 검색하는 과정이 매우 빠릅니다.
*   **단점**:
    *   가장 위의 데이터(top)에만 접근할 수 있어 중간 데이터에 대한 접근이 불가능합니다.

## 5. Python 구현 템플릿 (Python Template)

파이썬에서는 리스트를 스택처럼 사용할 수 있습니다. `append()`가 `push` 역할을, `pop()`이 `pop` 역할을 합니다.

```python
# 스택을 활용한 올바른 괄호 확인 예제

def is_valid_parentheses(s):
    stack = []
    # 괄호 짝을 딕셔너리로 저장
    mapping = {")": "(", "}": "{", "]": "["}

    for char in s:
        # 여는 괄호인 경우, 스택에 추가
        if char in mapping.values():
            stack.append(char)
        # 닫는 괄호인 경우
        elif char in mapping.keys():
            # 스택이 비어있거나, 짝이 맞지 않으면 False
            if not stack or mapping[char] != stack.pop():
                return False
        # 괄호가 아닌 문자는 무시
        else:
            continue

    # 모든 순회가 끝난 후 스택이 비어있어야 올바른 괄호
    return not stack

# 예시
s1 = "()[]{}"
s2 = "([)]"
print(f"'{s1}'는 올바른 괄호인가? {is_valid_parentheses(s1)}") # 출력: '()[]{}'는 올바른 괄호인가? True
print(f"'{s2}'는 올바른 괄호인가? {is_valid_parentheses(s2)}") # 출력: '([)]'는 올바른 괄호인가? False
```

---

# 큐 (Queue)

## 1. 개념 요약 (What is it?)

큐는 데이터가 순서대로 줄을 서는 자료구조로, 가장 먼저 들어온 데이터가 가장 먼저 나가는 **선입선출(FIFO, First-In, First-Out)** 특징을 가집니다.

## 2. 핵심 아이디어 (Core Idea)

큐는 양쪽이 뚫린 파이프와 같습니다. 데이터는 한쪽 끝(rear)으로 들어가고, 다른 쪽 끝(front)으로 나옵니다.

*   **비유**: 은행 창구나 놀이공원에서 줄을 서서 기다리는 것과 같습니다. 가장 먼저 줄을 선 사람(가장 먼저 들어온 데이터)이 가장 먼저 서비스를 받습니다.

## 3. 코딩 테스트 활용 전략 (When to Use)

*   **너비 우선 탐색(BFS)**: 그래프의 모든 정점을 같은 레벨(거리) 순서대로 탐색해야 할 때 반드시 사용됩니다. (예: 최단 경로 문제)
*   **선착순 처리**: 작업이나 데이터를 들어온 순서대로 처리해야 할 때 사용됩니다. (예: 프린터 인쇄 대기열, 프로세스 스케줄링)
*   **캐시(Cache) 구현**: LRU(Least Recently Used) 알고리즘 등에서 사용될 수 있습니다.

## 4. 시간 복잡도 및 장단점 (Complexity & Trade-offs)

*   **시간 복잡도**:
    *   데이터 추가(`enqueue`), 삭제(`dequeue`): **O(1)**
*   **장점**:
    *   데이터가 들어온 순서대로 처리되는 것을 보장합니다.
    *   BFS와 같은 알고리즘 구현에 필수적입니다.
*   **단점**:
    *   중간에 있는 데이터에 접근하기 어렵습니다.

## 5. Python 구현 템플릿 (Python Template)

파이썬 리스트의 `pop(0)`은 O(N)의 시간 복잡도를 가져 비효율적이므로, 시간 복잡도 O(1)을 보장하는 `collections.deque`를 사용하는 것이 필수적입니다.

```python
from collections import deque

# 큐를 활용한 BFS 기본 템플릿 (그래프 최단 거리 찾기 등)

def bfs(graph, start_node):
    # 방문 여부를 기록할 집합(set)과 탐색을 위한 큐
    visited = set()
    queue = deque([start_node])
    visited.add(start_node)

    while queue: # 큐가 빌 때까지 반복
        # 큐의 맨 앞에서 노드를 하나 꺼냄
        node = queue.popleft() # deque의 popleft()는 O(1)
        print(node, end=' ') # 현재 노드 방문 처리

        # 현재 노드와 연결된 다른 노드를 확인
        for neighbor in graph[node]:
            # 아직 방문하지 않은 노드라면
            if neighbor not in visited:
                # 큐에 추가하고 방문 처리
                queue.append(neighbor)
                visited.add(neighbor)

# 예시 그래프 (인접 리스트 방식)
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print("BFS 탐색 순서:")
bfs(graph, 'A') # 출력: BFS 탐색 순서: A B C D E F
``````